单例模式

优点：
1.在内存里只有一个实例，减少了内存开销
2.可以避免对资源的多重占用
3.设置全局访问点，严格控制访问

缺点：
1.没有接口，扩展困难

重点：
1.私有构造器
2.线程安全
3.延迟加载
4.序列化和反序列化安全
5.防止反射攻击

实用技能：
1.反编译
2.内存原理
3.多线程debug

相关设计模式：
1.单例模式和工厂模式
2.单例模式和享元模式

Coding……
>>>饿汉式
HungrySingleton
类初始化时就将对象创建完成，线程安全，如果这类型的类少，可以这么做，如果多的话，系统初始化时就将所有的单例类初始化完成，并没有真正用到，则造成内存资源浪费
比方说，游戏中有一个“超级兵”，它在游戏中被推掉水晶才会出现，如果进入游戏就将其初始化好，会造成两种情况：1.游戏加载慢，2.敌方投降导致游戏结束，这个超级兵被创建后从未使用过

>>>懒汉式
类初始化时先声明，用到的时候再创建
1.LazySingleton 懒汉式及debug多线程调试，线程不安全
2.LazySingletonSync 方法或代码块添加Synchronized同步锁，线程安全，但是效率太低（每个线程访问时得先获取锁）  Frames not available for unsuspended thread
3.LazySingletonDoubleCheckSync 双重检查锁 每个线程在获取锁之前，先进行一次判空，如果不为空，直接返回，无需关心锁；线程安全，效率有提高，但是有指令重排序问题
指令重排序：
初始化一个对象时，<1>.分配对象的内存空间 <2>.初始化对象 <3>.引用指向对象内存地址
在单线程初始化对象时，为提高效率，jvm可能会将<2> <3>顺序颠倒，导致指令重排，这样会造成的问题：
Thread-0执行了<1>后，直接执行<3>，但是在执行<2>之前，Thread-1进行了对象的判空操作，不为空，Thread-1直接将对象返回了，但此时步骤<2>还未初始化对象，导致Thread-1返回的对象有问题
解决办法：
1.给对象加上volatile关键字 作用:使变量线程间可见;从汇编语言层面防止创建对象时指令重排
2.LazySingletonStaticInner 使用静态内部类，类的初始化阶段：class被加载后，线程使用前，jvm会去获取一个Class对象的初始化锁，这个锁可以同步多个线程对一个类的初始化
所以初始化类时，同时只能有一个线程对其初始化操作，其他线程只能等待；要点：在静态内部类中直接创建一个类对象，只有在使用静态内部类时，才会去创建，无需担心像饿汉式一样造成资源浪费
5种情况会初始化一个类 >A类实例被创建 >A类中声明的静态方法被调用 >A类中声明的一个静态成员被赋值 >A类中一个静态成员被使用，并且该成员不是一个常量 >A类中是一个顶级类，有嵌套的断言语句
说了这么多，使用静态内部类这种方式，其实就是使用了静态内部类这样的一个类初始化锁，只有一个线程可以拿到这把锁


>>>破坏单例模式
1.序列化与反序列化 ObjectOutputStream ObjectInputStream readResolve()
2.反射破坏，将私有构造器权限打开
防止反射破坏：在私有构造器中抛出异常，单例构造器禁止反射调用 对HungrySingleton、LazySingletonStaticInner有用，因为这两种方式在类加载时，实例就已经创建好了

>>>枚举单例
EnumProtect
1.序列化与反序列化 不能破坏  ObjectInputStream中判断对象是枚举类型时，直接将对象返回，单例内部的其他成员属性也不会变
2.反射  不能破坏  枚举没有无参构造，即使通过有参构造创建对象，会报Cannot reflectively create enum objects异常
3.jad工具
4.枚举实例可以添加方法，但需要在外层定义一个抽象方法，不然外部调用不到

>>>容器单例
将单例对象放到一个map容器中，HashMap线程不安全，CurrentHashMap线程安全（折中方案），Hashtable线程安全（性能不高）

>>>ThreadLocal线程单例
不能保证全局唯一，但可以保证线程唯一

>>>源码中应用
1.Runtime   饿汉式单例
2.Desktop   类似于容器单例
3.Mybatis-ErrorContext   ThreadLocal单例